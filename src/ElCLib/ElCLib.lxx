// Created on: 1991-12-17
// Created by: Jean-Claude Vauthier
// Copyright (c) 1991-1999 Matra Datavision
// Copyright (c) 1999-2014 OPEN CASCADE SAS
//
// This file is part of Open CASCADE Technology software library.
//
// This library is free software; you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License version 2.1 as published
// by the Free Software Foundation, with special exception defined in the file
// OCCT_LGPL_EXCEPTION.txt. Consult the file LICENSE_LGPL_21.txt included in OCCT
// distribution for complete text of the license and disclaimer of any warranty.
//
// Alternatively, this file may be used under the terms of Open CASCADE
// commercial license or contractual agreement.

#include <gp_Lin.hxx>
#include <gp_Circ.hxx>
#include <gp_Parab.hxx>
#include <gp_Hypr.hxx>
#include <gp_Elips.hxx>
#include <gp_Lin2d.hxx>
#include <gp_Circ2d.hxx>
#include <gp_Parab2d.hxx>
#include <gp_Hypr2d.hxx>
#include <gp_Elips2d.hxx>

inline Point3d ElCLib1::Value(const Standard_Real U, const gp_Lin& L)
{

  return ElCLib1::LineValue(U, L.Position1());
}

inline Point3d ElCLib1::Value(const Standard_Real U, const gp_Circ& C)
{

  return ElCLib1::CircleValue(U, C.Position1(), C.Radius());
}

inline void ElCLib1::D1(const Standard_Real U, const gp_Lin& L, Point3d& P, Vector3d& V1)
{

  ElCLib1::LineD1(U, L.Position1(), P, V1);
}

inline void ElCLib1::D1(const Standard_Real U, const gp_Circ& C, Point3d& P, Vector3d& V1)
{

  ElCLib1::CircleD1(U, C.Position1(), C.Radius(), P, V1);
}

inline void ElCLib1::D2(const Standard_Real U, const gp_Circ& C, Point3d& P, Vector3d& V1, Vector3d& V2)
{

  ElCLib1::CircleD2(U, C.Position1(), C.Radius(), P, V1, V2);
}

inline void ElCLib1::D3(const Standard_Real U,
                       const gp_Circ&      C,
                       Point3d&             P,
                       Vector3d&             V1,
                       Vector3d&             V2,
                       Vector3d&             V3)
{

  ElCLib1::CircleD3(U, C.Position1(), C.Radius(), P, V1, V2, V3);
}

inline Point3d ElCLib1::Value(const Standard_Real U, const gp_Elips& E)
{
  return ElCLib1::EllipseValue(U, E.Position1(), E.MajorRadius(), E.MinorRadius());
}

inline void ElCLib1::D1(const Standard_Real U, const gp_Elips& E, Point3d& P, Vector3d& V1)
{

  ElCLib1::EllipseD1(U, E.Position1(), E.MajorRadius(), E.MinorRadius(), P, V1);
}

inline void ElCLib1::D2(const Standard_Real U, const gp_Elips& E, Point3d& P, Vector3d& V1, Vector3d& V2)
{

  ElCLib1::EllipseD2(U, E.Position1(), E.MajorRadius(), E.MinorRadius(), P, V1, V2);
}

inline void ElCLib1::D3(const Standard_Real U,
                       const gp_Elips&     E,
                       Point3d&             P,
                       Vector3d&             V1,
                       Vector3d&             V2,
                       Vector3d&             V3)
{

  ElCLib1::EllipseD3(U, E.Position1(), E.MajorRadius(), E.MinorRadius(), P, V1, V2, V3);
}

inline Point3d ElCLib1::Value(const Standard_Real U, const gp_Hypr& H)
{

  return ElCLib1::HyperbolaValue(U, H.Position1(), H.MajorRadius(), H.MinorRadius());
}

inline void ElCLib1::D1(const Standard_Real U, const gp_Hypr& H, Point3d& P, Vector3d& V1)
{

  ElCLib1::HyperbolaD1(U, H.Position1(), H.MajorRadius(), H.MinorRadius(), P, V1);
}

inline void ElCLib1::D2(const Standard_Real U, const gp_Hypr& H, Point3d& P, Vector3d& V1, Vector3d& V2)
{

  ElCLib1::HyperbolaD2(U, H.Position1(), H.MajorRadius(), H.MinorRadius(), P, V1, V2);
}

inline void ElCLib1::D3(const Standard_Real U,
                       const gp_Hypr&      H,
                       Point3d&             P,
                       Vector3d&             V1,
                       Vector3d&             V2,
                       Vector3d&             V3)
{

  ElCLib1::HyperbolaD3(U, H.Position1(), H.MajorRadius(), H.MinorRadius(), P, V1, V2, V3);
}

inline Point3d ElCLib1::Value(const Standard_Real U, const gp_Parab& Prb)
{

  return ElCLib1::ParabolaValue(U, Prb.Position1(), Prb.Focal());
}

inline void ElCLib1::D1(const Standard_Real U, const gp_Parab& Prb, Point3d& P, Vector3d& V1)
{

  ElCLib1::ParabolaD1(U, Prb.Position1(), Prb.Focal(), P, V1);
}

inline void ElCLib1::D2(const Standard_Real U,
                       const gp_Parab&     Prb,
                       Point3d&             P,
                       Vector3d&             V1,
                       Vector3d&             V2)
{

  ElCLib1::ParabolaD2(U, Prb.Position1(), Prb.Focal(), P, V1, V2);
}

inline gp_Pnt2d ElCLib1::Value(const Standard_Real U, const gp_Lin2d& L)
{

  return ElCLib1::LineValue(U, L.Position1());
}

inline gp_Pnt2d ElCLib1::Value(const Standard_Real U, const gp_Circ2d& C)
{

  return ElCLib1::CircleValue(U, C.Axis(), C.Radius());
}

inline gp_Pnt2d ElCLib1::Value(const Standard_Real U, const gp_Elips2d& E)
{

  return ElCLib1::EllipseValue(U, E.Axis(), E.MajorRadius(), E.MinorRadius());
}

inline gp_Pnt2d ElCLib1::Value(const Standard_Real U, const gp_Hypr2d& H)
{

  return ElCLib1::HyperbolaValue(U, H.Axis(), H.MajorRadius(), H.MinorRadius());
}

inline gp_Pnt2d ElCLib1::Value(const Standard_Real U, const gp_Parab2d& Prb)
{

  return ElCLib1::ParabolaValue(U, Prb.Axis(), Prb.Focal());
}

inline void ElCLib1::D1(const Standard_Real U, const gp_Lin2d& L, gp_Pnt2d& P, gp_Vec2d& V1)
{

  ElCLib1::LineD1(U, L.Position1(), P, V1);
}

inline void ElCLib1::D1(const Standard_Real U, const gp_Circ2d& C, gp_Pnt2d& P, gp_Vec2d& V1)
{

  ElCLib1::CircleD1(U, C.Axis(), C.Radius(), P, V1);
}

inline void ElCLib1::D1(const Standard_Real U, const gp_Elips2d& E, gp_Pnt2d& P, gp_Vec2d& V1)
{

  ElCLib1::EllipseD1(U, E.Axis(), E.MajorRadius(), E.MinorRadius(), P, V1);
}

inline void ElCLib1::D1(const Standard_Real U, const gp_Hypr2d& H, gp_Pnt2d& P, gp_Vec2d& V1)
{
  ElCLib1::HyperbolaD1(U, H.Axis(), H.MajorRadius(), H.MinorRadius(), P, V1);
}

inline void ElCLib1::D1(const Standard_Real U, const gp_Parab2d& Prb, gp_Pnt2d& P, gp_Vec2d& V1)
{

  ElCLib1::ParabolaD1(U, Prb.Axis(), Prb.Focal(), P, V1);
}

inline void ElCLib1::D2(const Standard_Real U,
                       const gp_Circ2d&    C,
                       gp_Pnt2d&           P,
                       gp_Vec2d&           V1,
                       gp_Vec2d&           V2)
{

  ElCLib1::CircleD2(U, C.Axis(), C.Radius(), P, V1, V2);
}

inline void ElCLib1::D2(const Standard_Real U,
                       const gp_Elips2d&   E,
                       gp_Pnt2d&           P,
                       gp_Vec2d&           V1,
                       gp_Vec2d&           V2)
{

  ElCLib1::EllipseD2(U, E.Axis(), E.MajorRadius(), E.MinorRadius(), P, V1, V2);
}

inline void ElCLib1::D2(const Standard_Real U,
                       const gp_Hypr2d&    H,
                       gp_Pnt2d&           P,
                       gp_Vec2d&           V1,
                       gp_Vec2d&           V2)
{

  ElCLib1::HyperbolaD2(U, H.Axis(), H.MajorRadius(), H.MinorRadius(), P, V1, V2);
}

inline void ElCLib1::D2(const Standard_Real U,
                       const gp_Parab2d&   Prb,
                       gp_Pnt2d&           P,
                       gp_Vec2d&           V1,
                       gp_Vec2d&           V2)
{

  ElCLib1::ParabolaD2(U, Prb.Axis(), Prb.Focal(), P, V1, V2);
}

inline void ElCLib1::D3(const Standard_Real U,
                       const gp_Circ2d&    C,
                       gp_Pnt2d&           P,
                       gp_Vec2d&           V1,
                       gp_Vec2d&           V2,
                       gp_Vec2d&           V3)
{

  ElCLib1::CircleD3(U, C.Axis(), C.Radius(), P, V1, V2, V3);
}

inline void ElCLib1::D3(const Standard_Real U,
                       const gp_Elips2d&   E,
                       gp_Pnt2d&           P,
                       gp_Vec2d&           V1,
                       gp_Vec2d&           V2,
                       gp_Vec2d&           V3)
{

  ElCLib1::EllipseD3(U, E.Axis(), E.MajorRadius(), E.MinorRadius(), P, V1, V2, V3);
}

inline void ElCLib1::D3(const Standard_Real U,
                       const gp_Hypr2d&    H,
                       gp_Pnt2d&           P,
                       gp_Vec2d&           V1,
                       gp_Vec2d&           V2,
                       gp_Vec2d&           V3)
{

  ElCLib1::HyperbolaD3(U, H.Axis(), H.MajorRadius(), H.MinorRadius(), P, V1, V2, V3);
}

inline Vector3d ElCLib1::DN(const Standard_Real U, const gp_Lin& L, const Standard_Integer N)
{

  return ElCLib1::LineDN(U, L.Position1(), N);
}

inline Vector3d ElCLib1::DN(const Standard_Real U, const gp_Circ& C, const Standard_Integer N)
{

  return ElCLib1::CircleDN(U, C.Position1(), C.Radius(), N);
}

inline Vector3d ElCLib1::DN(const Standard_Real U, const gp_Elips& E, const Standard_Integer N)
{

  return ElCLib1::EllipseDN(U, E.Position1(), E.MajorRadius(), E.MinorRadius(), N);
}

inline Vector3d ElCLib1::DN(const Standard_Real U, const gp_Hypr& H, const Standard_Integer N)
{

  return ElCLib1::HyperbolaDN(U, H.Position1(), H.MajorRadius(), H.MinorRadius(), N);
}

inline Vector3d ElCLib1::DN(const Standard_Real U, const gp_Parab& Prb, const Standard_Integer N)
{

  return ElCLib1::ParabolaDN(U, Prb.Position1(), Prb.Focal(), N);
}

inline gp_Vec2d ElCLib1::DN(const Standard_Real U, const gp_Lin2d& L, const Standard_Integer N)
{

  return ElCLib1::LineDN(U, L.Position1(), N);
}

inline gp_Vec2d ElCLib1::DN(const Standard_Real U, const gp_Circ2d& C, const Standard_Integer N)
{

  return ElCLib1::CircleDN(U, C.Axis(), C.Radius(), N);
}

inline gp_Vec2d ElCLib1::DN(const Standard_Real U, const gp_Elips2d& E, const Standard_Integer N)
{
  return ElCLib1::EllipseDN(U, E.Axis(), E.MajorRadius(), E.MinorRadius(), N);
}

inline gp_Vec2d ElCLib1::DN(const Standard_Real U, const gp_Hypr2d& H, const Standard_Integer N)
{

  return ElCLib1::HyperbolaDN(U, H.Axis(), H.MajorRadius(), H.MinorRadius(), N);
}

inline gp_Vec2d ElCLib1::DN(const Standard_Real U, const gp_Parab2d& Prb, const Standard_Integer N)
{

  return ElCLib1::ParabolaDN(U, Prb.Axis(), Prb.Focal(), N);
}

inline Standard_Real ElCLib1::Parameter(const gp_Lin& L, const Point3d& P)
{

  return ElCLib1::LineParameter(L.Position1(), P);
}

inline Standard_Real ElCLib1::Parameter(const gp_Circ& C, const Point3d& P)
{

  return ElCLib1::CircleParameter(C.Position1(), P);
}

inline Standard_Real ElCLib1::Parameter(const gp_Elips& E, const Point3d& P)
{

  return ElCLib1::EllipseParameter(E.Position1(), E.MajorRadius(), E.MinorRadius(), P);
}

inline Standard_Real ElCLib1::Parameter(const gp_Hypr& H, const Point3d& P)
{

  return ElCLib1::HyperbolaParameter(H.Position1(), H.MajorRadius(), H.MinorRadius(), P);
}

inline Standard_Real ElCLib1::Parameter(const gp_Parab& Prb, const Point3d& P)
{

  return ElCLib1::ParabolaParameter(Prb.Position1(), P);
}

inline Standard_Real ElCLib1::Parameter(const gp_Lin2d& L, const gp_Pnt2d& P)
{

  return ElCLib1::LineParameter(L.Position1(), P);
}

inline Standard_Real ElCLib1::Parameter(const gp_Circ2d& C, const gp_Pnt2d& P)
{

  return ElCLib1::CircleParameter(C.Axis(), P);
}

inline Standard_Real ElCLib1::Parameter(const gp_Elips2d& E, const gp_Pnt2d& P)
{

  return ElCLib1::EllipseParameter(E.Axis(), E.MajorRadius(), E.MinorRadius(), P);
}

inline Standard_Real ElCLib1::Parameter(const gp_Hypr2d& H, const gp_Pnt2d& P)
{

  return ElCLib1::HyperbolaParameter(H.Axis(), H.MajorRadius(), H.MinorRadius(), P);
}

inline Standard_Real ElCLib1::Parameter(const gp_Parab2d& Prb, const gp_Pnt2d& P)
{

  return ElCLib1::ParabolaParameter(Prb.Axis(), P);
}
